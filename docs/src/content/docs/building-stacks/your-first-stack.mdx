---
title: Your First Stack
sidebar:
  order: 5
---

In this tutorial, you'll build an end-to-end streaming data pipeline in 15 minutes. We'll create a "Counter" stack that tracks on-chain increment events and displays the live count in a React app.

## What You'll Build

A full-stack streaming application consisting of:

1. **A Rust Definition**: Defines how to transform on-chain Solana events into a "Counter" entity.
2. **A Cloud Deployment**: A managed Hyperstack instance that processes the stream.
3. **A React Frontend**: A live dashboard that updates instantly as on-chain events occur.

---

## Part 1: Create the Stack (Rust)

The stack definition is the heart of your application. It tells Hyperstack which on-chain data to watch and how to project it into a useful state.

### 1. Create a new Rust project

```bash
cargo new counter-stack --lib
cd counter-stack
```

### 2. Add dependencies

Add `hyperstack` to your `Cargo.toml`:

```toml
[dependencies]
hyperstack = "0.2"
serde = { version = "1.0", features = ["derive"] }
```

### 3. Write your stack definition

Open `src/lib.rs` and define your projection. For this tutorial, we'll assume a simple Solana program with a `CounterAccount` and an `Increment` instruction.

```rust
// src/lib.rs
use hyperstack::{hyperstack, Stream, Strategy};

#[hyperstack(idl = "counter_idl.json")]
pub mod counter_stack {
    use super::*;

    #[entity]
    #[derive(Stream)]
    pub struct Counter {
        #[map(from = "CounterAccount", field = "authority", primary_key = true)]
        pub owner: String,

        #[aggregate(from = "Increment", field = "amount", strategy = Sum)]
        pub total_count: u64,

        #[derive_from(from = "Increment", field = "__timestamp")]
        pub last_updated: i64,
    }
}
```

### 4. Build to generate AST

Hyperstack uses **AST serialization**. When you compile your code, it automatically generates a `.hyperstack/Counter.ast.json` file.

```bash
cargo build
```

:::tip[Checkpoint]
Verify that the file `.hyperstack/Counter.ast.json` exists in your project root. This JSON file contains the compiled logic of your stream.
:::

---

## Part 2: Deploy to Hyperstack Cloud

Now let's push your stack to the cloud. Hyperstack manages the infrastructure, so you don't need to worry about scaling or WebSocket servers.

### 1. Login to the CLI

```bash
hs auth login
```

### 2. Initialize your project

This creates a `hyperstack.toml` file that links your local AST to the cloud.

```bash
hs init
```

### 3. Push and Deploy

The `up` command is a shortcut that pushes your AST, builds the container, and deploys it to a global cluster.

```bash
hs up counter-stack
```

**Expected Output:**

```text
âœ” Stack pushed (v1)
âœ” Build created (id: bld_123...)
âœ” Build completed
ðŸš€ Deployed to: wss://ore.stack.usehyperstack.com
```

:::tip[Checkpoint]
Copy the **WebSocket URL** from the output. You'll need it for the React app.
:::

---

## Part 3: Generate SDK and Connect

Finally, let's build the frontend. First, generate a typed SDK from your deployed stack, then connect using React or TypeScript.

:::tip[What is the SDK?]
The generated SDK contains the typed interface to your stack â€” it tells the Hyperstack client what entities exist, what views are available, and the TypeScript types for each. You can share this SDK with your team or publish it.
:::

### 1. Generate the SDK

From your stack project directory (where you ran `hs up`):

```bash
hs sdk create typescript counter-stack --output ./sdk
```

This creates a typed SDK in `./sdk/` with full TypeScript support.

---

import { Tabs, TabItem } from "@astrojs/starlight/components";

<Tabs>
<TabItem label="React">

### 2. Set up your React app

```bash
npx create-react-app my-counter-app --template typescript
cd my-counter-app
npm install hyperstack-react zustand
```

Copy the generated SDK into your React app:

```bash
cp -r ../counter-stack/sdk ./src/counter-sdk
```

### 3. Configure the Provider

Wrap your app in `HyperstackProvider` using the URL from `hs up`.

```tsx
// src/index.tsx
import { HyperstackProvider } from "hyperstack-react";

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(
  <HyperstackProvider websocketUrl="wss://ore.stack.usehyperstack.com">
    <App />
  </HyperstackProvider>,
);
```

### 4. Use the Generated Stack

```tsx
// src/App.tsx
import { useHyperstack } from "hyperstack-react";
import { CounterStack } from "./counter-sdk";

export default function App() {
  const stack = useHyperstack(CounterStack);
  const { data: counters, isLoading } = stack.views.counters.list.use();

  if (isLoading) return <div>Connecting to stream...</div>;

  return (
    <div>
      <h1>Live Counters</h1>
      {counters?.map((c) => (
        <div
          key={c.owner}
          style={{ padding: "1rem", border: "1px solid #ccc" }}
        >
          <h3>Owner: {c.owner}</h3>
          <p>
            Count: <strong>{c.total_count}</strong>
          </p>
          <small>
            Last updated: {new Date(c.last_updated * 1000).toLocaleString()}
          </small>
        </div>
      ))}
    </div>
  );
}
```

</TabItem>
<TabItem label="TypeScript (Non-React)">

### 2. Set up your project

```bash
mkdir my-counter-app && cd my-counter-app
npm init -y
npm install hyperstack-typescript typescript
```

Copy the generated SDK:

```bash
cp -r ../counter-stack/sdk ./src/counter-sdk
```

### 3. Connect and stream data

```typescript
// src/index.ts
import { HyperStack } from "hyperstack-typescript";
import { CounterStack, type Counter } from "./counter-sdk";

async function main() {
  // Connect to your deployed stack using the generated SDK
  const hs = await HyperStack.connect(
    "wss://ore.stack.usehyperstack.com",
    { stack: CounterStack }
  );

  console.log("Connected! Streaming counters...\n");

  // Stream updates with full type safety
  for await (const update of hs.subscribe<Counter>("Counter/list")) {
    if (update.type === "upsert") {
      const counter = update.data;
      console.log(`Counter updated:`);
      console.log(`  Owner: ${counter.owner}`);
      console.log(`  Count: ${counter.total_count}`);
      console.log(
        `  Last updated: ${new Date(counter.last_updated * 1000).toLocaleString()}`,
      );
      console.log("");
    }
  }
}

main().catch(console.error);
```

### 4. Run your app

```bash
npx tsx src/index.ts
```

</TabItem>
</Tabs>

---

## Troubleshooting

### "AST file not found"

Ensure you ran `cargo build` in your Rust project. The `#[hyperstack]` macro generates the AST file during compilation.

### WebSocket connection fails

1. Check that the URL matches the output of `hs up`.
2. Ensure your stack is successfully deployed by running `hs stack list`.

### Data is not appearing

1. Verify that your Solana program is actually emitting the events or updating the accounts defined in your stack.
2. Check the browser console for any subscription errors.

## Next Steps

- Learn more about [Stack Macros](/building-stacks/macros) to build complex pipelines.
- Explore [Population Strategies](/building-stacks/strategies) for different data access patterns.
- Check the [CLI Reference](/cli/commands) for advanced deployment options.
