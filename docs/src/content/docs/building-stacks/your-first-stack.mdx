---
title: Your First Stack
sidebar:
  order: 4
---

In this tutorial, you'll build an end-to-end real-time data pipeline in 15 minutes. We'll create a "Counter" stack that tracks on-chain increment events and displays the live count in a React app.

## What You'll Build

A full-stack streaming application consisting of:

1. **A Rust Definition**: Defines how to transform on-chain Solana events into a "Counter" entity.
2. **A Cloud Deployment**: A managed Hyperstack instance that processes the stream.
3. **A React Frontend**: A live dashboard that updates instantly as on-chain events occur.

---

## Part 1: Create the Stack (Rust)

The stack definition is the heart of your application. It tells Hyperstack which on-chain data to watch and how to project it into a useful state.

### 1. Create a new Rust project

```bash
cargo new counter-stack --lib
cd counter-stack
```

### 2. Add dependencies

Add `hyperstack` to your `Cargo.toml`:

```toml
[dependencies]
hyperstack = "0.2"
serde = { version = "1.0", features = ["derive"] }
```

### 3. Write your stack definition

Open `src/lib.rs` and define your projection. For this tutorial, we'll assume a simple Solana program with a `CounterAccount` and an `Increment` instruction.

```rust
// src/lib.rs
use hyperstack::{hyperstack, Stream, Strategy};

#[hyperstack(idl = "counter_idl.json")]
pub mod counter_stack {
    use super::*;

    #[entity]
    #[derive(Stream)]
    pub struct Counter {
        #[map(from = "CounterAccount", field = "authority", primary_key = true)]
        pub owner: String,

        #[aggregate(from = "Increment", field = "amount", strategy = Sum)]
        pub total_count: u64,

        #[derive_from(from = "Increment", field = "__timestamp")]
        pub last_updated: i64,
    }
}
```

### 4. Build to generate AST

Hyperstack uses **AST serialization**. When you compile your code, it automatically generates a `.hyperstack/Counter.ast.json` file.

```bash
cargo build
```

:::tip[Checkpoint]
Verify that the file `.hyperstack/Counter.ast.json` exists in your project root. This JSON file contains the compiled logic of your stream.
:::

---

## Part 2: Deploy to Hyperstack Cloud

Now let's push your stack to the cloud. Hyperstack manages the infrastructure, so you don't need to worry about scaling or WebSocket servers.

### 1. Login to the CLI

```bash
hs auth login
```

### 2. Initialize your project

This creates a `hyperstack.toml` file that links your local AST to the cloud.

```bash
hs init
```

### 3. Push and Deploy

The `up` command is a shortcut that pushes your AST, builds the container, and deploys it to a global cluster.

```bash
hs up counter-stack
```

**Expected Output:**

```text
âœ” Stack pushed (v1)
âœ” Build created (id: bld_123...)
âœ” Build completed
ðŸš€ Deployed to: wss://counter-stack.stack.usehyperstack.com
```

:::tip[Checkpoint]
Copy the **WebSocket URL** from the output. You'll need it for the React app.
:::

---

## Part 3: Connect from Your App

Finally, let's build the frontend. You can use either the React SDK or the pure TypeScript SDK.

import { Tabs, TabItem } from "@astrojs/starlight/components";

<Tabs>
<TabItem label="React">

### 1. Set up your React app

```bash
npx create-react-app my-counter-app --template typescript
cd my-counter-app
npm install hyperstack-react zustand
```

### 2. Configure the Provider

Wrap your app in `HyperstackProvider` using the URL you got from the previous step.

```tsx
// src/index.tsx
import { HyperstackProvider } from "hyperstack-react";

const root = ReactDOM.createRoot(document.getElementById("root")!);
root.render(
  <HyperstackProvider websocketUrl="wss://counter-stack.stack.usehyperstack.com">
    <App />
  </HyperstackProvider>,
);
```

### 3. Define the Stack

Tell the React SDK about your "Counter" entity.

```tsx
// src/stack.ts
import { defineStack, createListView } from "hyperstack-react";

export interface Counter {
  owner: string;
  total_count: number;
  last_updated: number;
}

export const CounterStack = defineStack({
  name: "counter-stack",
  views: {
    counters: {
      list: createListView<Counter>("Counter/list"),
    },
  },
});
```

### 4. Build the Component

Create a component that displays the live data.

```tsx
// src/App.tsx
import { useHyperstack } from "hyperstack-react";
import { CounterStack } from "./stack";

export default function App() {
  const stack = useHyperstack(CounterStack);
  const { data: counters, isLoading } = stack.views.counters.list.use();

  if (isLoading) return <div>Connecting to stream...</div>;

  return (
    <div>
      <h1>Live Counters</h1>
      {counters?.map((c) => (
        <div
          key={c.owner}
          style={{ padding: "1rem", border: "1px solid #ccc" }}
        >
          <h3>Owner: {c.owner}</h3>
          <p>
            Count: <strong>{c.total_count}</strong>
          </p>
          <small>
            Last updated: {new Date(c.last_updated * 1000).toLocaleString()}
          </small>
        </div>
      ))}
    </div>
  );
}
```

</TabItem>
<TabItem label="TypeScript (Non-React)">

### 1. Set up your project

```bash
mkdir my-counter-app && cd my-counter-app
npm init -y
npm install hyperstack-typescript typescript
```

### 2. Connect and stream data

```typescript
// src/index.ts
import { HyperStack } from "hyperstack-typescript";

interface Counter {
  owner: string;
  total_count: number;
  last_updated: number;
}

async function main() {
  // Connect to your deployed stack
  const hs = await HyperStack.connect(
    "wss://counter-stack.stack.usehyperstack.com",
  );

  console.log("Connected! Streaming counters...\n");

  // Stream updates using AsyncIterable
  for await (const update of hs.views.counters.list.watch()) {
    if (update.type === "upsert") {
      const counter = update.data as Counter;
      console.log(`Counter updated:`);
      console.log(`  Owner: ${counter.owner}`);
      console.log(`  Count: ${counter.total_count}`);
      console.log(
        `  Last updated: ${new Date(counter.last_updated * 1000).toLocaleString()}`,
      );
      console.log("");
    }
  }
}

main().catch(console.error);
```

### 3. Run your app

```bash
npx tsx src/index.ts
```

</TabItem>
</Tabs>

---

## Troubleshooting

### "AST file not found"

Ensure you ran `cargo build` in your Rust project. The `#[hyperstack]` macro generates the AST file during compilation.

### WebSocket connection fails

1. Check that the URL matches the output of `hs up`.
2. Ensure your stack is successfully deployed by running `hs stack list`.

### Data is not appearing

1. Verify that your Solana program is actually emitting the events or updating the accounts defined in your stack.
2. Check the browser console for any subscription errors.

## Next Steps

- Learn more about [Stack Macros](/building-stacks/macros) to build complex pipelines.
- Explore [Population Strategies](/building-stacks/strategies) for different data access patterns.
- Check the [CLI Reference](/cli/commands) for advanced deployment options.
