---
title: Stack Definitions
sidebar:
  order: 2
description: Introduction to the Hyperstack Rust DSL for defining streaming data specifications.
---

Hyperstack uses a declarative Rust DSL (Domain Specific Language) to define how on-chain Solana data should be transformed, aggregated, and streamed to your application. Instead of writing complex ETL pipelines, you simply declare the final state you want, and Hyperstack handles the rest.

---

## Why Declarative?

Building data pipelines for Solana typically involves manual account parsing, complex event handling, and managing state synchronization. Hyperstack replaces this imperative approach with a declarative model:

| Imperative Approach (Traditional)             | Declarative Approach (Hyperstack)                 |
| --------------------------------------------- | ------------------------------------------------- |
| Write custom decoding logic for every account | Use `#[map]` to link IDL fields to your state     |
| Manually track and sum event values           | Use `#[aggregate(strategy = Sum)]`                |
| Manage WebSocket connections and state diffs  | Define entities and let Hyperstack stream updates |
| Build custom backend services for data        | Deploy a stack and use generated SDKs             |

---

## Anatomy of a Stack Definition

A Hyperstack definition is a Rust module annotated with `#[hyperstack]`. Inside this module, you define **Entities**—the structured data objects your application will consume. A single module can contain multiple `#[entity]` structs, all packaged into one stack.

```rust
use hyperstack::prelude::*;

#[hyperstack(idl = "path/to/idl.json")]
pub mod my_stream {
    use hyperstack::macros::Stream;
    use serde::{Deserialize, Serialize};

    #[entity(name = "Token")]
    pub struct Token {
        pub id: TokenId,
        pub state: TokenState,
        pub metrics: TokenMetrics,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, Stream)]
    pub struct TokenId {
        /// The primary key (mint address)
        #[map(pump_sdk::accounts::BondingCurve::mint, primary_key, strategy = SetOnce)]
        pub mint: String,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, Stream)]
    pub struct TokenState {
        /// Live reserves mapped from account state
        #[map(pump_sdk::accounts::BondingCurve::reserves, strategy = LastWrite)]
        pub reserves: Option<u64>,

        /// Computed field derived from existing fields
        #[computed(state.reserves.map(|r| r * 100))]
        pub tvl: Option<u64>,
    }

    #[derive(Debug, Clone, Serialize, Deserialize, Stream)]
    pub struct TokenMetrics {
        /// Total volume aggregated from individual trade events
        #[aggregate(from = pump_sdk::instructions::Trade, field = amount, strategy = Sum, lookup_by = accounts::mint)]
        pub total_volume: Option<u64>,
    }
}
```

:::note[SDK Module Naming]
Hyperstack derives the program name from the IDL metadata and generates a typed SDK module named `{name}_sdk`. For example, an IDL for the "pump" program produces `pump_sdk::accounts::*` and `pump_sdk::instructions::*`. All `#[map]` and `#[aggregate]` paths use this prefix.
:::

### Key Components

1.  **`#[hyperstack]` Module**: The container for your definition. It links to your data sources (IDL or Protobuf files). The `idl` argument also accepts an array for multi-program stacks: `idl = ["pump.json", "raydium.json"]`.
2.  **`#[entity]` Struct**: Defines a projection of on-chain data. Each entity represents a collection of related data that will be streamed as a single unit. Entities compose nested structs—they do NOT use `#[derive(Stream)]`.
3.  **`#[derive(Stream)]` Structs**: Nested structs that contain the actual field mappings. These derive `Stream` along with `Debug`, `Clone`, `Serialize`, and `Deserialize`.
4.  **Primary Key**: Every entity must have a primary key (usually a `Pubkey` or `String`). This is how Hyperstack tracks individual instances of an entity.
5.  **Field Mappings**: Attributes on struct fields that define where the data comes from and how it's processed.

---

## Mapping Types

Hyperstack provides several mapping attributes to populate your entity fields:

| Attribute             | Source              | Description                                                                                                                                                   |
| --------------------- | ------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `#[map]`              | Account State       | Tracks fields within a Solana account. Updates whenever the account changes. Supports `lookup_index(register_from = [...])` for cross-account PDA resolution. |
| `#[from_instruction]` | Instructions        | Extracts arguments or account keys from a specific instruction.                                                                                               |
| `#[aggregate]`        | Events/Instructions | Computes running values (Sum, Count, etc.) from a stream of events.                                                                                           |
| `#[event]`            | Events              | Captures specific instructions as a log of events within the entity.                                                                                          |
| `#[snapshot]`         | Account State       | Captures the entire state of an account at a specific point in time.                                                                                          |
| `#[computed]`         | Local Fields        | Derives a new value by performing calculations on other fields in the same entity.                                                                            |
| `#[derive_from]`      | Instructions        | Populates fields by deriving data from instruction context.                                                                                                   |

---

## Population Strategies

When data arrives, **Strategies** determine how the field value is updated. This is particularly powerful for aggregations.

| Strategy      | Behavior                                                              |
| ------------- | --------------------------------------------------------------------- |
| `LastWrite`   | (Default) Overwrites the field with the latest value.                 |
| `SetOnce`     | Sets the value once and ignores subsequent updates (perfect for IDs). |
| `Sum`         | Adds the incoming value to the existing total.                        |
| `Count`       | Increments the total by 1 for every matching event.                   |
| `Append`      | Adds the incoming value to a list (creating an event log).            |
| `Max` / `Min` | Keeps only the highest or lowest value seen.                          |

---

## Multi-Program Stacks

A single stack can consume data from multiple Solana programs by passing an array of IDL files:

```rust
#[hyperstack(idl = ["idl/ore.json", "idl/entropy.json"])]
pub mod ore_stream {
    // ore_sdk::accounts::* and ore_sdk::instructions::* are available
    // entropy_sdk::accounts::* and entropy_sdk::instructions::* are available
}
```

Each IDL generates its own namespaced SDK module (e.g., `ore_sdk`, `entropy_sdk`). You can then map fields from any program's accounts and reference instructions from any program in `register_from`, `#[aggregate]`, `#[event]`, etc.

To link accounts across programs, use `lookup_index(register_from = [...])` — see the [Macro Reference](/building-stacks/rust-dsl/macros#cross-account-resolution-with-register_from) for the full syntax and examples.

---

## Example WebSocket Frames

The stack definition above produces WebSocket frames with the following structure. An `upsert` frame contains the full entity state:

```json
{
  "op": "upsert",
  "mode": "state",
  "entity": "Token",
  "key": "So11111111111111111111111111111111111111112",
  "data": {
    "id": {
      "mint": "So11111111111111111111111111111111111111112"
    },
    "state": {
      "reserves": 1500000000,
      "tvl": 150000000000
    },
    "metrics": {
      "total_volume": 42000000000
    }
  }
}
```

When only specific fields change, a `patch` frame contains just the updated values:

```json
{
  "op": "patch",
  "mode": "state",
  "entity": "Token",
  "key": "So11111111111111111111111111111111111111112",
  "data": {
    "state": {
      "reserves": 1520000000,
      "tvl": 152000000000
    }
  }
}
```

The SDK merges patches into local state automatically, so your application always sees the complete entity.

---

## Next Steps

- [Mapping Macros](./rust-dsl/macros) — Deep dive into every mapping attribute and its parameters.
- [Aggregation Strategies](./rust-dsl/strategies) — Learn how to build complex metrics using different strategies.
- [CLI Reference](/cli/commands) — Learn how to build and deploy your stacks.
