---
title: Workflow
sidebar:
  order: 1
description: The end-to-end process of building and deploying a Hyperstack data pipeline.
---

import { Tabs, TabItem } from "@astrojs/starlight/components";
import Workflow from "../../../components/Workflow.astro";

Building a stack follows a straightforward four-step workflow: define your data model in Rust, compile to build the stack, deploy to Hyperstack Cloud, and connect from your application.

<Workflow steps={[
  {
    title: "Write Rust",
    description: "Define entities using #[hyperstack] macro"
  },
  {
    title: "Build Stack", 
    description: "Compile with cargo build"
  },
  {
    title: "Deploy via CLI",
    description: "Push to cloud with hs up"
  },
  {
    title: "Connect from App",
    description: "Use generated SDK to stream"
  }
]} />

---

## Step 1: Write Your Stack Definition

A stack definition is a Rust module that maps structure from the IDL into a rich, queryable state ready to consume in your application layer. Using Hyperstack's expressive DSL, you define **entities**, field mappings, aggregations, computed fields, relationships, and more â€” all in declarative Rust syntax.

```rust
use hyperstack::{hyperstack, Stream};

#[hyperstack(idl = "my_program.json")]
pub mod ore_stack {
    #[entity]
    #[derive(Stream)]
    pub struct OreRound {
        #[map(RoundState::round_id, primary_key)]
        pub round_id: u64,

        #[map(RoundState::motherlode)]
        pub motherlode: u64,

        #[map(RoundState::difficulty)]
        pub difficulty: u64,
    }
}
```

The Rust code is purely declarativeâ€”you're describing **what** data you want, not **how** to fetch it. Hyperstack handles all the account parsing, event processing, and state management.

:::note
In practice, field paths use fully qualified names with the generated SDK module: e.g., `ore_sdk::accounts::RoundState::round_id`. The module name (`ore_sdk`) is derived from the IDL's program metadata. The example above is simplified for clarity.
:::

â†’ [Stack Definitions](/building-stacks/stack-definitions) â€” Learn the full DSL syntax

---

## Step 2: Build the Stack

When you compile your Rust project, Hyperstack macros transform your definition into a portable JSON specification. This is the compiled representation of your data pipeline.

```bash
cargo build
```

After building, you'll find the generated specification in `.hyperstack/`:

```
my-stack/
â”œâ”€â”€ src/lib.rs
â”œâ”€â”€ Cargo.toml
â””â”€â”€ .hyperstack/
    â””â”€â”€ OreStack.stack.json    # Generated stack specification
```

The `.stack.json` file contains everything Hyperstack needs to execute your pipeline: all entities, field mappings, aggregation logic, key resolution rules, and more. A single stack file can contain multiple entities.

---

## Step 3: Deploy with the CLI

The Hyperstack CLI (`hs`) handles deployment to Hyperstack Cloud. A single command pushes your stack specification, builds the execution environment, and deploys to a global edge network.

:::caution[Closed Beta]
Hyperstack is currently in closed beta. You'll need an API key to deploy. [Contact us on X](https://x.com/usehyperstack) to request access.
:::

```bash
# Initialize project config (creates hyperstack.toml)
hs init

# Deploy your stack
hs up
```

On success, you'll receive a WebSocket URL:

```
âœ” Stack pushed (v1)
âœ” Build completed
ðŸš€ Deployed to: wss://ore.stack.usehyperstack.com
```

â†’ [CLI Reference](/cli/commands) â€” Full command documentation

---

## Step 4: Generate SDK and Connect

Once deployed, generate a typed SDK for your stack:

<Tabs>
<TabItem label="TypeScript">

```bash
hs sdk create typescript ore
```

</TabItem>
<TabItem label="Rust">

```bash
hs sdk create rust ore
```

</TabItem>
</Tabs>

This creates a package containing the stack definition that tells the Hyperstack client how to interact with your feed, including all entities and their views. Import it in your application:

<Tabs>
<TabItem label="React">

```tsx
import { HyperstackProvider, useHyperstack } from "hyperstack-react";
import { ORE_STREAM_STACK } from "hyperstack-stacks/ore"; // Generated in Step 4

// Wrap your app
<HyperstackProvider>
  <App />
</HyperstackProvider>;

// In your component
const stack = useHyperstack(ORE_STREAM_STACK);
const { data: rounds } = stack.views.OreRound.list.use();
```

</TabItem>
<TabItem label="TypeScript">

```typescript
import { HyperStack } from "hyperstack-typescript";
import { ORE_STREAM_STACK } from "hyperstack-stacks/ore"; // Generated in Step 4

const hs = await HyperStack.connect(ORE_STREAM_STACK);

for await (const round of hs.views.OreRound.list.use()) {
  console.log("Round updated:", round);
}
```

</TabItem>
<TabItem label="Rust">

```rust
use hyperstack_sdk::prelude::*;
use ore_stack::{OreStack, OreRound};  // Generated in Step 4

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Connect to your deployed stack
    let hs = HyperStack::<OreStack>::connect().await?;

    // Stream updates via typed views
    let mut stream = hs.views.ore_round.latest().listen();

    while let Some(round) = stream.next().await {
        println!("Round #{:?}: motherlode={:?}",
            round.id.round_id, round.state.motherlode);
    }

    Ok(())
}
```

</TabItem>
</Tabs>

Share the generated SDK with your team or publish it â€” anyone with the SDK can connect to your stack's feed (assuming they're authorized).

â†’ [Your First Stack](/building-stacks/your-first-stack) â€” Complete tutorial with working code

---

## Next Steps

| Goal                                | Page                                                          |
| ----------------------------------- | ------------------------------------------------------------- |
| Understand the DSL in depth         | [Stack Definitions](/building-stacks/stack-definitions)       |
| Set up your development environment | [Installation](/building-stacks/installation)                 |
| Build a complete example            | [Your First Stack](/building-stacks/your-first-stack)         |
| Learn all available macros          | [Macro Reference](/building-stacks/rust-dsl/macros)           |
| Master aggregation strategies       | [Population Strategies](/building-stacks/rust-dsl/strategies) |
