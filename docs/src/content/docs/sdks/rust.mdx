---
title: Rust SDK
sidebar:
  order: 3
---

The Hyperstack Rust SDK is a high-performance, asynchronous client for consuming streaming data from Hyperstack. It is designed for backend services, trading bots, and CLI tools that require type-safe access to Solana state projections.

---

## Installation

Add to your `Cargo.toml`:

```toml
[dependencies]
hyperstack-sdk = "0.2"
hyperstack-stacks = { version = "0.2", optional = true }
tokio = { version = "1", features = ["full"] }
anyhow = "1"
futures = "0.3"
```

The `hyperstack-stacks` crate provides pre-built stack definitions for popular Solana protocols (optional but recommended).

### TLS Options

By default, the SDK uses `rustls` for TLS. You can switch to native TLS:

```toml
[dependencies]
hyperstack-sdk = { version = "0.2", default-features = false, features = ["native-tls"] }
```

### Tokio Runtime

The SDK requires the [Tokio](https://tokio.rs/) runtime. Ensure you have it enabled in your project (specifically the `rt-multi-thread`, `macros`, and `time` features).

---

## Quick Start

### Connect and Stream

```rust
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::OreRoundViews;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    // Connect to the public ORE stack
    let hs = HyperStack::connect("wss://ore.stack.usehyperstack.com").await?;
    
    println!("Connected! Streaming ORE rounds...\n");

    // Get typed views
    let views = hs.views::<OreRoundViews>();
    let mut stream = views.latest().watch();

    // Stream updates
    while let Some(update) = stream.next().await {
        match update {
            Update::Upsert { data, .. } | Update::Patch { data, .. } => {
                println!("Round # {:?}", data.id.round_id);
                println!("  Motherlode: {:?}", data.state.motherlode);
                println!("  Total difficulty: {:?}\n", data.state.total_difficulty);
            }
            Update::Delete { key } => println!("Round deleted: {}\n", key),
        }
    }

    Ok(())
}
```

Run with:

```bash
cargo run
```

---

## Project Setup

### 1. Create a New Project

```bash
cargo new my-hyperstack-app
cd my-hyperstack-app
```

### 2. Add Dependencies

```toml
[dependencies]
hyperstack-sdk = "0.2"
hyperstack-stacks = "0.2"
tokio = { version = "1", features = ["rt-multi-thread", "macros"] }
anyhow = "1"
futures = "0.3"
```

### 3. Basic Structure

```rust
// src/main.rs
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::OreRoundViews;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let hs = HyperStack::connect("wss://ore.stack.usehyperstack.com").await?;
    
    let views = hs.views::<OreRoundViews>();
    let mut stream = views.latest().watch();

    while let Some(update) = stream.next().await {
        handle_update(update);
    }

    Ok(())
}

fn handle_update(update: Update<OreRound>) {
    match update {
        Update::Upsert { key, data } => {
            println!("Upsert - Key: {:?}, Round: {:?}", key, data.id.round_id);
        }
        Update::Patch { key, data, .. } => {
            println!("Patch - Key: {:?}, Round: {:?}", key, data.id.round_id);
        }
        Update::Delete { key } => {
            println!("Delete - Key: {:?}", key);
        }
    }
}
```

---

## Connection Management

### Basic Connection

```rust
let hs = HyperStack::connect("wss://ore.stack.usehyperstack.com").await?;
```

### With Options

```rust
use hyperstack_sdk::ConnectionOptions;

let options = ConnectionOptions {
    max_entries_per_view: Some(5000),  // Limit memory usage
    ..Default::default()
};

let hs = HyperStack::connect_with_options(
    "wss://ore.stack.usehyperstack.com",
    options
).await?;
```

### Builder Pattern

Configure the client with custom reconnection logic and intervals:

```rust
use std::time::Duration;

let hs = HyperStack::builder()
    .url("wss://ore.stack.usehyperstack.com")
    .auto_reconnect(true)
    .max_reconnect_attempts(10)
    .reconnect_intervals(vec![
        Duration::from_secs(1),
        Duration::from_secs(2),
        Duration::from_secs(5),
    ])
    .ping_interval(Duration::from_secs(30))
    .initial_data_timeout(Duration::from_secs(5))  // Timeout for get()/list()
    .max_entries_per_view(5000)  // Limit entries per view (default: 10,000)
    .connect()
    .await?;
```

### Connection State

```rust
// Check current state
match hs.connection_state() {
    ConnectionState::Connected => println!("Connected!"),
    ConnectionState::Connecting => println!("Connecting..."),
    ConnectionState::Disconnected => println!("Disconnected"),
    ConnectionState::Reconnecting => println!("Reconnecting..."),
}

// Listen for state changes
hs.on_connection_state_change(|state| {
    println!("Connection state changed: {:?}", state);
});
```

### Disconnect

```rust
// Graceful disconnect
hs.disconnect().await?;
```

---

## Store Size Limits

By default, each view is limited to 10,000 entries to prevent memory issues on long-running clients. When the limit is reached, oldest entries are evicted (LRU).

```rust
// Custom limit
let hs = HyperStack::builder()
    .url("wss://ore.stack.usehyperstack.com")
    .max_entries_per_view(5000)
    .connect()
    .await?;

// Unlimited (not recommended for long-running clients)
let hs = HyperStack::builder()
    .url("wss://ore.stack.usehyperstack.com")
    .max_entries_per_view(None)
    .connect()
    .await?;
```

---

## Views

Views provide typed access to your stack's data. The `hyperstack-stacks` crate includes pre-built view definitions for popular protocols.

### Using Pre-Built Views

```rust
use hyperstack_stacks::ore::OreRoundViews;

let views = hs.views::<OreRoundViews>();
```

### Custom Views

For your own stacks, define the view interface:

```rust
use hyperstack_sdk::{View, ListView, StateView};

// Define your entity
#[derive(Debug, Clone)]
struct Token {
    mint: String,
    name: String,
    symbol: String,
    price: Option<u64>,
}

// Define views trait
trait TokenViews {
    fn all(&self) -> ListView<Token>;
    fn by_mint(&self) -> StateView<Token>;
}

impl TokenViews for Views {
    fn all(&self) -> ListView<Token> {
        self.list_view("Token/list")
    }
    
    fn by_mint(&self) -> StateView<Token> {
        self.state_view("Token/state")
    }
}
```

---

## Streaming Data

### Watch a List View

Stream all entities in a collection:

```rust
let views = hs.views::<OreRoundViews>();
let mut stream = views.latest().watch();

while let Some(update) = stream.next().await {
    match update {
        Update::Upsert { data, .. } => {
            println!("New/Updated round: {:?}", data.id.round_id);
        }
        Update::Delete { key } => {
            println!("Removed round: {:?}", key);
        }
        _ => {}
    }
}
```

### Watch a Single Entity

Stream updates for a specific entity:

```rust
let specific_round = "some-round-key";
let mut stream = views.latest().watch_by_key(specific_round);

while let Some(update) = stream.next().await {
    println!("Round updated: {:?}", update);
}
```

### Limit Stream

Use standard stream adapters:

```rust
use futures::StreamExt;

// Take only the first 10 updates
let mut stream = views.latest().watch().take(10);

while let Some(update) = stream.next().await {
    println!("Update: {:?}", update);
}
```

### Filter While Streaming

```rust
use futures::StreamExt;

let mut stream = views.latest().watch().filter(|update| {
    futures::future::ready(matches!(update, Update::Upsert { .. }))
});

// Only receives upsert events
while let Some(update) = stream.next().await {
    println!("Upsert: {:?}", update);
}
```

### Lazy Streams with Chainable Operators

Streams are **lazy** - calling `watch()` returns immediately without subscribing. The subscription happens automatically on first poll. This enables ergonomic method chaining:

```rust
use std::collections::HashSet;

let watchlist: HashSet<String> = /* tokens to watch */;

let mut price_alerts = hs
    .watch_rich::<PumpfunTokenEntity>()
    .filter(move |u| watchlist.contains(u.key()))
    .filter_map(|update| match update {
        RichUpdate::Updated { before, after, .. } => {
            let prev = before.trading.last_trade_price.flatten().unwrap_or(0.0);
            let curr = after.trading.last_trade_price.flatten().unwrap_or(0.0);
            if prev > 0.0 {
                let pct = (curr - prev) / prev * 100.0;
                if pct.abs() > 0.1 {
                    return Some((after.info.name.clone(), pct));
                }
            }
            None
        }
        _ => None,
    });

while let Some((name, pct)) = price_alerts.next().await {
    println!("[PRICE] {:?} changed by {:.2}%", name, pct);
}
```

#### Available Stream Operators

| Operator             | Description                              |
| -------------------- | ---------------------------------------- |
| `.filter(predicate)` | Keep only updates matching the predicate |
| `.filter_map(f)`     | Filter and transform in one step         |
| `.map(f)`            | Transform each update                    |

All operators are chainable and return streams that support the same operators.

---

## One-Shot Queries

Fetch current state without streaming:

```rust
// Get all entities
let rounds: Vec<OreRound> = views.latest().get_all().await?;
println!("Found {} rounds", rounds.len());

// Get a single entity
let round: Option<OreRound> = views.latest().get_by_key("round-key").await?;
if let Some(r) = round {
    println!("Round: {:?}", r.id.round_id);
}
```

---

## Core Methods

| Method                     | Returns               | Description                              |
| -------------------------- | --------------------- | ---------------------------------------- |
| `get::<E>(key).await`      | `Option<T>`           | Get a single entity by key               |
| `list::<E>().await`        | `Vec<T>`              | Get all entities of type E               |
| `watch::<E>()`             | `EntityStream<T>`     | Stream all updates (lazy)                |
| `watch_key::<E>(key)`      | `EntityStream<T>`     | Stream updates for a specific key (lazy) |
| `watch_keys::<E>(&[keys])` | `EntityStream<T>`     | Stream updates for multiple keys (lazy)  |
| `watch_rich::<E>()`        | `RichEntityStream<T>` | Stream with before/after values (lazy)   |
| `watch_key_rich::<E>(key)` | `RichEntityStream<T>` | Rich stream for specific key (lazy)      |
| `connection_state().await` | `ConnectionState`     | Get current connection state             |
| `disconnect().await`       | `()`                  | Close the connection                     |

---

## Update Types

When streaming with `watch()`, you receive `Update<T>` variants:

```rust
pub enum Update<T> {
    Upsert { key: String, data: T },  // Full entity update
    Patch { key: String, data: T },   // Partial update (merged)
    Delete { key: String },           // Entity removed
}
```

Helper methods: `key()`, `data()`, `is_delete()`, `has_data()`, `into_data()`, `into_key()`, `map(f)`

### Rich Updates (Before/After Diffs)

For tracking changes over time, use `watch_rich()`:

```rust
pub enum RichUpdate<T> {
    Created { key: String, data: T },
    Updated { key: String, before: T, after: T, patch: Option<Value> },
    Deleted { key: String, last_known: Option<T> },
}
```

The `Updated` variant includes `patch` - the raw JSON of changed fields, useful for checking what specifically changed:

```rust
if update.has_patch_field("trading") {
    // The trading field was modified
}
```

---

## Understanding `Option<Option<T>>` Fields

Generated entity types often have fields typed as `Option<Option<T>>`. This represents the **patch semantics** of HyperStack updates:

| Value               | Meaning                                               |
| ------------------- | ----------------------------------------------------- |
| `None`              | Field was **not included** in this update (no change) |
| `Some(None)`        | Field was **explicitly set to null**                  |
| `Some(Some(value))` | Field has a **concrete value**                        |

This distinction matters for partial updates (patches). When the server sends a patch, only changed fields are included. An absent field means "keep the previous value", while an explicit `null` means "clear this field".

### Working with `Option<Option<T>>`

```rust
// Access a nested optional field
let price = token.trading.last_trade_price.flatten().unwrap_or(0.0);

// Check if field was explicitly set (vs absent from patch)
match &token.reserves.current_price_sol {
    None => println!("Price not in this update"),
    Some(None) => println!("Price explicitly cleared"),
    Some(Some(price)) => println!("Price: {}", price),
}

// Compare values in before/after
if before.trading.last_trade_price != after.trading.last_trade_price {
    println!("Price changed!");
}
```

---

## Generating a Rust SDK

Use the HyperStack CLI to generate a typed Rust SDK from your spec:

```bash
# Generate SDK crate
hs sdk create rust settlement-game

# With custom output directory
hs sdk create rust settlement-game --output ./crates/game-sdk

# With custom crate name
hs sdk create rust settlement-game --crate-name game-sdk

# Generate as a module instead of a standalone crate
hs sdk create rust settlement-game --module --output ./src/stacks/game
```

### Crate vs Module Output

By default, the CLI generates a **standalone crate** with its own `Cargo.toml`:

```
generated/settlement-game-stack/
├── Cargo.toml
└── src/
    ├── lib.rs      # Re-exports
    ├── types.rs    # Data structs (with Option<Option<T>> for patchable fields)
    └── entity.rs   # Entity trait implementations
```

With the `--module` flag, the CLI generates a **module** that can be embedded in an existing crate:

```
src/stacks/game/
├── mod.rs      # Re-exports
├── types.rs    # Data structs
└── entity.rs   # Entity trait implementations
```

The module mode is useful for:

- Monorepo setups where you want generated code alongside your source
- Avoiding extra crate dependencies
- Embedding multiple stacks within a single crate

### Configuration

You can set module mode as the default in `hyperstack.toml`:

```toml
[sdk]
rust_module_mode = true  # Generate all Rust SDKs as modules

# Or per-stack:
[[stacks]]
name = "game"
ast = "SettlementGame"
rust_module = true  # This stack generates as a module
```

### Using the Generated Code

Add the generated crate to your `Cargo.toml`:

```toml
[dependencies]
hyperstack-sdk = "0.2"
settlement-game-stack = { path = "./generated/settlement-game-stack" }
```

Or if using module mode, add to your `lib.rs`:

```rust
pub mod game;  // Points to src/game/mod.rs
```

---

## Error Handling

```rust
use hyperstack_sdk::HyperstackError;

match HyperStack::connect("wss://ore.stack.usehyperstack.com").await {
    Ok(hs) => println!("Connected!"),
    Err(HyperstackError::Connection(e)) => {
        eprintln!("Connection failed: {}", e);
    }
    Err(HyperstackError::Authentication(e)) => {
        eprintln!("Auth failed: {}", e);
    }
    Err(e) => {
        eprintln!("Unexpected error: {:?}", e);
    }
}
```

---

## Auto-Reconnection

The SDK automatically reconnects on connection loss with configurable backoff:

```rust
let hs = HyperStack::builder()
    .url("wss://ore.stack.usehyperstack.com")
    .auto_reconnect(true)
    .reconnect_intervals(vec![
        Duration::from_secs(1),
        Duration::from_secs(2),
        Duration::from_secs(5),
        Duration::from_secs(10),
    ])
    .max_reconnect_attempts(20)
    .connect()
    .await?;
```

---

## Complete Example

A full command-line app that streams ORE mining rounds:

```rust
// src/main.rs
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::OreRoundViews;
use std::time::Duration;
use tokio::time::timeout;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    println!("╭────────────────────────────────────╮");
    println!("│  Hyperstack ORE Round Monitor     │");
    println!("╰────────────────────────────────────╯\n");

    // Connect with 10 second timeout
    let hs = match timeout(
        Duration::from_secs(10),
        HyperStack::connect("wss://ore.stack.usehyperstack.com")
    ).await {
        Ok(Ok(hs)) => {
            println!("✓ Connected to ORE stack\n");
            hs
        }
        Ok(Err(e)) => {
            eprintln!("✗ Connection error: {}", e);
            return Err(e.into());
        }
        Err(_) => {
            eprintln!("✗ Connection timeout");
            return Err(anyhow::anyhow!("Connection timeout"));
        }
    };

    // Get views
    let views = hs.views::<OreRoundViews>();
    
    // Stream with stats
    let mut round_count = 0;
    let mut update_count = 0;
    let mut stream = views.latest().watch();

    println!("Streaming live ORE rounds (press Ctrl+C to exit)...\n");

    while let Some(update) = stream.next().await {
        update_count += 1;
        
        match update {
            Update::Upsert { data, .. } => {
                round_count += 1;
                println!(
                    "[#{:03}] Round #{} - Motherlode: {} SOL",
                    update_count,
                    data.id.round_id,
                    data.state.motherlode as f64 / 1_000_000_000.0
                );
            }
            Update::Patch { data, .. } => {
                println!(
                    "[#{:03}] Updated Round #{} - Difficulty: {}",
                    update_count,
                    data.id.round_id,
                    data.state.total_difficulty
                );
            }
            Update::Delete { key } => {
                println!("[#{:03}] Removed round: {:?}", update_count, key);
            }
        }

        // Print stats every 10 updates
        if update_count % 10 == 0 {
            println!("\n--- Stats: {} rounds tracked, {} updates received ---\n", 
                round_count, update_count);
        }
    }

    Ok(())
}
```

Run it:

```bash
cargo run
```

---

## Advanced Patterns

### Multiple Concurrent Streams

```rust
use futures::future::join;

let views = hs.views::<OreRoundViews>();

// Watch multiple views concurrently
let latest_stream = views.latest().watch();
let historical_stream = views.historical().watch();

let (latest_result, historical_result) = join(
    process_stream(latest_stream),
    process_stream(historical_stream)
).await;
```

### Reconnection Handling

```rust
loop {
    match HyperStack::connect("wss://ore.stack.usehyperstack.com").await {
        Ok(hs) => {
            println!("Connected!");
            
            let views = hs.views::<OreRoundViews>();
            let mut stream = views.latest().watch();
            
            while let Some(update) = stream.next().await {
                process_update(update);
            }
            
            // Stream ended - connection lost
            println!("Connection lost, reconnecting...");
        }
        Err(e) => {
            eprintln!("Connection failed: {}, retrying in 5s...", e);
            tokio::time::sleep(Duration::from_secs(5)).await;
        }
    }
}
```

### Graceful Shutdown

```rust
use tokio::signal;

let hs = HyperStack::connect("wss://ore.stack.usehyperstack.com").await?;
let views = hs.views::<OreRoundViews>();
let mut stream = views.latest().watch();

// Handle Ctrl+C
let ctrl_c = signal::ctrl_c();

loop {
    tokio::select! {
        Some(update) = stream.next() => {
            process_update(update);
        }
        _ = ctrl_c => {
            println!("\nShutting down gracefully...");
            hs.disconnect().await?;
            break;
        }
    }
}
```

---

## Examples

See the `examples/` directory for complete examples:

- **flip/** - Flip game state tracking
- **pump/** - Token launch and trade monitoring

Run examples with:

```bash
cargo run --example flip
cargo run --example pump_new
cargo run --example pump_trades
```

---

## Next Steps

- [TypeScript SDK](/sdks/typescript/) — Use Hyperstack in Node.js or browsers
- [React SDK](/sdks/react/) — Build web apps with React hooks
- [Build Your Own Stack](/building-stacks/workflow) — Create custom data streams for any Solana program
- [CLI Reference](/cli/commands) — Deployment and management commands
