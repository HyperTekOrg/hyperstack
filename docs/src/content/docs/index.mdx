---
title: Hyperstack
description: Programmable data feeds for Solana
---

import { Card, CardGrid, Tabs, TabItem } from "@astrojs/starlight/components";

**Hyperstack is a system for programmable data feeds on Solana.**

Stream any on-chain data to your app in real-time. No custom indexers. No RPC polling. No infrastructure to manage.

Define the data you need, deploy it, and start streaming in minutes.

---

## What Hyperstack Handles

Building real-time Solana data pipelines typically requires:

- **Yellowstone gRPC** connections to stream raw transaction data
- **Custom parsers** for every account type and instruction
- **State management** to track entity lifecycles and compute aggregations
- **WebSocket infrastructure** to fan out updates to clients
- **Type definitions** kept in sync between backend and frontend

Hyperstack replaces all of this with a declarative definition and managed infrastructure.

---

## Stream an Existing Feed

If someone has already deployed a Hyperstack feed, you can connect and start streaming immediately.

<Tabs>
<TabItem label="React">
```tsx
import { HyperstackProvider, useHyperstack } from 'hyperstack-react';
import { PUMPFUN_TOKEN_STACK, PumpfunToken } from './generated/pumpfun-stack';

function App() {
return (

<HyperstackProvider 
      websocketUrl="wss://pumpfun-token-rfx6zp.stack.usehyperstack.com"
    >
<TokenFeed />
</HyperstackProvider>
);
}

function TokenFeed() {
const stack = useHyperstack(PUMPFUN_TOKEN_STACK);
const { data: tokens, isLoading } = stack.views.tokens.list.use();

if (isLoading) return <div>Connecting...</div>;

return (

<ul>
{tokens?.map(token => (
<li key={token.mint}>{token.name} - {token.symbol}</li>
))}
</ul>
);
}

````
</TabItem>
<TabItem label="TypeScript">
```typescript
import { HyperStack } from 'hyperstack-typescript';
import { PUMPFUN_TOKEN_STACK } from './generated/pumpfun-stack';

const hs = await HyperStack.connect(
  'wss://pumpfun-token-rfx6zp.stack.usehyperstack.com',
  { stack: PUMPFUN_TOKEN_STACK }
);

// Stream updates as they happen on-chain
for await (const update of hs.views.tokens.list.watch()) {
  if (update.type === 'upsert') {
    console.log('Token updated:', update.data.name, update.data.symbol);
  }
}
````

</TabItem>
<TabItem label="Rust">
```rust
use hyperstack_sdk::prelude::*;
use pumpfun_stack::PumpfunTokenEntity;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
let hs = HyperStack::connect(
"wss://pumpfun-token-rfx6zp.stack.usehyperstack.com"
).await?;

    // Stream updates as they happen on-chain
    let mut stream = hs.watch::<PumpfunTokenEntity>();
    while let Some(update) = stream.next().await {
        match update {
            Update::Upsert { data, .. } => {
                println!("Token: {} ({})", data.name, data.symbol);
            }
            _ => {}
        }
    }

    Ok(())

}

````
</TabItem>
</Tabs>

:::note[Generate the SDK]
The type-safe SDK for any deployed stack can be generated with the CLI:
```bash
hs sdk create typescript pumpfun-token --output ./generated
hs sdk create rust pumpfun-token --output ./generated
````

:::

---

## Create Your Own Feed

To stream data from your own Solana program, define a stack in Rust and deploy it.

### 1. Define Your Data Shape

Create a Rust crate with your stack definition:

```rust
use hyperstack::{hyperstack, Stream};

#[hyperstack(idl = "my_program.json")]
pub mod my_stack {
    /// Track token data from your program
    #[entity(name = "Token")]
    #[derive(Stream)]
    pub struct Token {
        // Primary key from instruction
        #[from_instruction(CreateToken::mint, primary_key)]
        pub mint: String,

        // Map fields from account state
        #[map(TokenAccount::name)]
        pub name: String,

        #[map(TokenAccount::symbol)]
        pub symbol: String,

        // Aggregate values from events
        #[aggregate(from = Trade, field = amount, strategy = Sum)]
        pub total_volume: u64,

        // Compute derived values
        #[computed(total_volume / 1_000_000)]
        pub volume_in_millions: u64,
    }
}
```

### 2. Build and Deploy

```bash
# Build generates the AST
cargo build

# Deploy to Hyperstack Cloud
hs auth login
hs init
hs up
```

Output:

```
âœ” Stack pushed (v1)
âœ” Build completed
ðŸš€ Deployed: wss://my-stack.stack.usehyperstack.com
```

### 3. Generate SDK and Connect

```bash
hs sdk create typescript my-stack
```

Then connect using the examples above.

---

## Capabilities

| Feature                 | Description                                                    |
| ----------------------- | -------------------------------------------------------------- |
| **Account state**       | Map fields directly from on-chain accounts                     |
| **Instructions**        | Extract arguments and accounts from program instructions       |
| **Aggregations**        | Compute Sum, Count, Max, Min, UniqueCount across events        |
| **Computed fields**     | Derive values from other fields                                |
| **PDA resolution**      | Automatically resolve related accounts                         |
| **Real-time streaming** | Updates pushed via WebSocket as they happen on-chain           |
| **Type-safe SDKs**      | Generated TypeScript and Rust clients with full type inference |

---

## Start Here

<CardGrid>
  <Card title="Try It Now" icon="rocket">
    Stream real-time Solana data in 2 minutes. No signup required.

    [Get started â†’](/using-stacks/try-it-now/)

  </Card>
  <Card title="Build Your Own Stack" icon="seti:rust">
    Create custom data streams for any Solana program.

    [Start building â†’](/building-stacks/your-first-stack/)

  </Card>
  <Card title="How It Works" icon="information">
    Architecture, data flow, and key concepts.

    [Learn more â†’](/concepts/overview/)

  </Card>
  <Card title="SDK Reference" icon="document">
    Full API documentation for React and TypeScript.

    [View reference â†’](/sdks/typescript/overview/)

  </Card>
</CardGrid>
