---
title: Hyperstack
description: Programmable data feeds for Solana
---

import { Card, CardGrid, Tabs, TabItem } from "@astrojs/starlight/components";

**Hyperstack is a system for programmable data feeds on Solana.**

Stream any on-chain data to your app as it happens. No custom indexers. No RPC polling. No infrastructure to manage.

---

## See It In Action

Connect to the public ORE mining rounds stack — anyone can use it, no account required.

<Tabs>
<TabItem label="React">
```tsx
import { HyperstackProvider, useHyperstack } from 'hyperstack-react';
import { OREROUND_STACK, OreRound } from 'hyperstack-stacks/ore';

function App() {
  return (
    <HyperstackProvider websocketUrl="wss://ore.stack.usehyperstack.com">
      <LatestRounds />
    </HyperstackProvider>
  );
}

function LatestRounds() {
  const stack = useHyperstack(OREROUND_STACK);
  const { data: rounds, isLoading } = stack.views.OreRound.latest.use({ take: 5 });

  if (isLoading) return <div>Connecting...</div>;

  return (
    <ul>
      {rounds?.map((round) => (
        <li key={round.id?.round_id}>
          Round #{round.id?.round_id} — Motherlode: {round.state?.motherlode}
        </li>
      ))}
    </ul>
  );
}
```
</TabItem>
<TabItem label="TypeScript">
```typescript
import { HyperStack } from 'hyperstack-typescript';
import { OREROUND_STACK, OreRound } from 'hyperstack-stacks/ore';

const hs = await HyperStack.connect('wss://ore.stack.usehyperstack.com', {
  stack: OREROUND_STACK,
});

for await (const update of hs.views.OreRound.latest.watch({ take: 1 })) {
  if (update.type === 'upsert') {
    console.log(`Round #${update.data.id?.round_id}`);
    console.log(`Motherlode: ${update.data.state?.motherlode}`);
  }
}
```
</TabItem>
<TabItem label="Rust">
```rust
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::OreRoundViews;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let hs = HyperStack::connect("wss://ore.stack.usehyperstack.com").await?;

    let views = hs.views::<OreRoundViews>();
    let mut stream = views.latest().watch().take(1);

    while let Some(update) = stream.next().await {
        match update {
            Update::Upsert { data, .. } | Update::Patch { data, .. } => {
                println!("Round # {:?}", data.id.round_id);
                println!("Motherlode: {:?}", data.state.motherlode);
            }
            _ => {}
        }
    }

    Ok(())
}
```
</TabItem>
</Tabs>

:::note[Stack SDKs]
The `hyperstack-stacks` package provides ready-to-use SDKs for popular Solana protocols. You can also [generate your own SDK](/building-stacks/workflow) from any stack you build. Install it alongside your SDK:
```bash
npm install hyperstack-stacks hyperstack-react
```

:::

---

## How It Works

Hyperstack handles the full pipeline from chain to client:

```
┌─────────────────┐     ┌─────────────────┐     ┌─────────────────┐
│     Solana       │ ──▶ │   Hyperstack    │ ──▶ │    Your App     │
│   (on-chain)     │     │  (transform +   │     │   (live feed)   │
│                  │     │    stream)       │     │                 │
└─────────────────┘     └─────────────────┘     └─────────────────┘
```

1. **Define** the data shape you need using a declarative Rust DSL
2. **Deploy** your definition — Hyperstack manages the infrastructure
3. **Stream** live updates to any client via WebSocket

---

## Capabilities

| Feature             | Description                                                          |
| ------------------- | -------------------------------------------------------------------- |
| **Account state**   | Map fields directly from on-chain accounts                           |
| **Instructions**    | Extract arguments and accounts from program instructions             |
| **Aggregations**    | Compute Sum, Count, Max, Min, UniqueCount across events              |
| **Computed fields** | Derive values from other fields                                      |
| **PDA resolution**  | Automatically resolve related accounts                               |
| **Live streaming**  | Updates pushed via WebSocket as they happen on-chain                 |
| **Type-safe SDKs**  | Generated TypeScript and Rust SDKs — share with your team or publish |

---

## I Want to Read Data

Connect to existing stacks and stream live Solana data into your app.

<CardGrid>
  <Card title="Quickstart" icon="rocket">
    **Create a new app** — The CLI scaffolds a complete working project in under 2 minutes.

    Choose React, TypeScript, or Rust templates.

    [Start here →](/using-stacks/quickstart/)

  </Card>
  <Card title="Connect to a Stack" icon="laptop">
    **Add to existing project** — Install the SDK and start streaming with a few lines of code.

    Works with any React, TypeScript, or Rust project.

    [Connect now →](/using-stacks/connect/)

  </Card>
</CardGrid>

---

## I Want to Build Stacks

Create custom data pipelines that transform on-chain events into structured, streaming feeds.

<CardGrid>
  <Card title="Your First Stack" icon="seti:rust">
    **End-to-end tutorial** — Build, deploy, and connect to your own custom stack.

    Define entities, write transformations, deploy to Hyperstack Cloud.

    [Build now →](/building-stacks/your-first-stack/)

  </Card>
  <Card title="How It Works" icon="information">
    **Architecture & concepts** — Understand the full Hyperstack system.

    Learn about entities, mappings, aggregations, and deployment.

    [Learn more →](/using-stacks/how-it-works/)

  </Card>
</CardGrid>
