---
title: Hyperstack
description: Programmable data feeds for Solana
---

import { Card, CardGrid, Tabs, TabItem } from "@astrojs/starlight/components";
import Workflow from "../../components/Workflow.astro";

**Hyperstack is a system for programmable data feeds on Solana.**

Stream any on-chain data to your app as it happens. No custom indexers. No RPC polling. No infrastructure to manage.

---

## See It In Action

Connect to the public ORE mining rounds stack â€” anyone can use it, no account required.

<Tabs>
<TabItem label="React">
```tsx
import { HyperstackProvider, useHyperstack } from 'hyperstack-react';
import { ORE_STREAM_STACK, type OreRound } from 'hyperstack-stacks/ore';

function App() {
  return (
    <HyperstackProvider>
      <LatestRounds />
    </HyperstackProvider>
  );
}

function LatestRounds() {
  const { views, isConnected } = useHyperstack(ORE_STREAM_STACK);
  const { data: rounds, isLoading } = views.OreRound.latest.use({ take: 5 });

  if (isLoading) return <div>Connecting...</div>;

  return (
    <div>
      <p>{isConnected ? "ðŸŸ¢ Live" : "Connecting..."}</p>
      <ul>
        {rounds?.map((round) => (
          <li key={round.id?.round_id}>
            Round #{round.id?.round_id} â€” Motherlode: {round.state?.motherlode}
          </li>
        ))}
      </ul>
    </div>
  );
}
```
</TabItem>
<TabItem label="TypeScript">
```typescript
import { HyperStack } from 'hyperstack-typescript';
import { ORE_STREAM_STACK, type OreRound } from 'hyperstack-stacks/ore';

// Connect using the stack (URL is embedded in the stack definition)
const hs = await HyperStack.connect(ORE_STREAM_STACK);

for await (const update of hs.views.OreRound.latest.watch({ take: 1 })) {
  if (update.type === 'upsert') {
    console.log(`Round #${update.data.id?.round_id}`);
    console.log(`Motherlode: ${update.data.state?.motherlode}`);
  }
}
```
</TabItem>
<TabItem label="Rust">
```rust
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::{OreStack, OreRound};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let hs = HyperStack::<OreStack>::connect().await?;

    let mut stream = hs.views.ore_round.latest().listen().take(1);

    while let Some(round) = stream.next().await {
        println!("Round # {:?}", round.id.round_id);
        println!("Motherlode: {:?}", round.state.motherlode);
    }

    Ok(())
}
```
</TabItem>
</Tabs>

:::note[Stack SDKs]
The `hyperstack-stacks` package provides ready-to-use SDKs for popular Solana protocols. You can also [generate your own SDK](/building-stacks/workflow) from any stack you build. Install it alongside your SDK:
```bash
npm install hyperstack-stacks hyperstack-react
```

:::

---

## How It Works

Hyperstack handles the full pipeline from chain to client:

<Workflow steps={[
  {
    title: "Solana",
    description: "On-chain data"
  },
  {
    title: "Hyperstack",
    description: "Transform + stream"
  },
  {
    title: "Your App",
    description: "Live feed"
  }
]} />

1. **Define** the data shape you need using a declarative Rust DSL
2. **Deploy** your definition â€” Hyperstack manages the infrastructure
3. **Stream** live updates to any client via WebSocket

---

## Capabilities

| Feature             | Description                                                          |
| ------------------- | -------------------------------------------------------------------- |
| **Account state**   | Map fields directly from on-chain accounts                           |
| **Instructions**    | Extract arguments and accounts from program instructions             |
| **Aggregations**    | Compute Sum, Count, Max, Min, UniqueCount across events              |
| **Computed fields** | Derive values from other fields                                      |
| **PDA resolution**  | Automatically resolve related accounts                               |
| **Live streaming**  | Updates pushed via WebSocket as they happen on-chain                 |
| **Type-safe SDKs**  | Generated TypeScript and Rust SDKs â€” share with your team or publish |

---

## I Want to Read Data

Connect to existing stacks and stream live Solana data into your app.

<CardGrid>
  <Card title="Quickstart" icon="rocket">
    **Create a new app** â€” The CLI scaffolds a complete working project in under 2 minutes.

    Choose React, TypeScript, or Rust templates.

    [Start here â†’](/using-stacks/quickstart/)

  </Card>
  <Card title="Connect to a Stack" icon="laptop">
    **Add to existing project** â€” Install the SDK and start streaming with a few lines of code.

    Works with any React, TypeScript, or Rust project.

    [Connect now â†’](/using-stacks/connect/)

  </Card>
</CardGrid>

---

## I'm Using an AI Coding Agent

Let your AI write the code. Agent skills teach Cursor, Claude Code, Windsurf, and other AI tools how to use Hyperstack.

<CardGrid>
  <Card title="Agent Skills" icon="star">
    **One command setup** â€” Install skills and your agent knows all the SDK patterns and CLI commands.

    Works with Cursor, Claude Code, Windsurf, VS Code Copilot, and 30+ other agents.

    [Install skills â†’](/agent-skills/overview/)

  </Card>
  <Card title="Schema Discovery" icon="magnifier">
    **Live type info** â€” Agents use `hs explore` to get exact entity names, field paths, and types from deployed stacks.

    Always accurate, always up to date.

    [Learn more â†’](/agent-skills/explore/)

  </Card>
</CardGrid>

---

## I Want to Build Stacks

Create custom data pipelines that transform on-chain events into structured, streaming feeds.

<CardGrid>
  <Card title="Your First Stack" icon="seti:rust">
    **End-to-end tutorial** â€” Build, deploy, and connect to your own custom stack.

    Define entities, write transformations, deploy to Hyperstack Cloud.

    [Build now â†’](/building-stacks/your-first-stack/)

  </Card>
  <Card title="How It Works" icon="information">
    **Architecture & concepts** â€” Understand the full Hyperstack system.

    Learn about entities, mappings, aggregations, and deployment.

    [Learn more â†’](/using-stacks/how-it-works/)

  </Card>
</CardGrid>
