---
title: Core Concepts
sidebar:
  order: 2
description: Understand Stacks, Views, and real-time data streaming.
---

Before diving deeper, here's a quick mental model of how Hyperstack works.

---

## The Three-Layer Model

```
┌──────────────────────────────────────────────────────────────┐
│  YOUR APP                                                    │
│  React hooks, TypeScript streams, or raw WebSocket           │
└──────────────────────────────────────────────────────────────┘
                              ▲
                              │ WebSocket (real-time updates)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  HYPERSTACK STACK                                            │
│  A deployed data pipeline that transforms on-chain events    │
│  into structured, typed data                                 │
└──────────────────────────────────────────────────────────────┘
                              ▲
                              │ Yellowstone gRPC (raw transactions)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  SOLANA                                                      │
│  On-chain programs emitting transactions and state changes   │
└──────────────────────────────────────────────────────────────┘
```

---

## What is a Stack?

A **Stack** is a deployed data pipeline that:

1. **Subscribes** to specific Solana program events
2. **Transforms** raw transaction data into structured entities
3. **Aggregates** values over time (sums, counts, etc.)
4. **Streams** updates to connected clients in real-time

Think of it as a "live query" against Solana — you define what data you want, and Hyperstack keeps it updated.

### Example: A Token Stack

A stack tracking pump.fun tokens might define:

```rust
#[entity(name = "PumpfunToken")]
pub struct PumpfunToken {
    #[from_instruction(Create::mint, primary_key)]
    pub mint: String,

    #[map(TokenAccount::name)]
    pub name: String,

    #[aggregate(from = Trade, field = amount, strategy = Sum)]
    pub total_volume: u64,
}
```

This tells Hyperstack:
- Create a `PumpfunToken` entity for each `Create` instruction
- Map the `name` field from the account state
- Sum all `Trade` amounts into `total_volume`

The result? A live, always-updating collection of tokens with their current stats.

---

## Views

**Views** are how you access data from a stack. There are two types:

### List View

Returns all entities as an array. Updates when any entity changes.

```typescript
// Get all tokens
const { data: tokens } = stack.views.tokens.list.use();
// tokens: PumpfunToken[]
```

### State View

Returns a single entity by its primary key. Updates when that specific entity changes.

```typescript
// Get one token by mint address
const { data: token } = stack.views.tokens.state.use({ 
  key: "So11111111111111111111111111111111111111112" 
});
// token: PumpfunToken | undefined
```

### View Paths

Views are addressed using the format `{EntityName}/{mode}`:

| View Path | Returns | Use Case |
|-----------|---------|----------|
| `Token/list` | `Token[]` | Show all tokens |
| `Token/state` | `Token` | Show one token by key |

---

## Real-Time Updates

Unlike traditional APIs where you poll for changes, Hyperstack **pushes** updates to you.

### How It Works

1. Something happens on Solana (new token, trade, state change)
2. Hyperstack's VM processes the transaction
3. If it affects your subscribed views, you get an update
4. Your app re-renders automatically (React) or receives the event (TypeScript)

### Update Types

| Type | Meaning |
|------|---------|
| `upsert` | Entity was created or updated |
| `delete` | Entity was removed |

```typescript
for await (const update of hs.subscribe('Token/list')) {
  if (update.type === 'upsert') {
    console.log('Token changed:', update.data);
  } else if (update.type === 'delete') {
    console.log('Token removed:', update.key);
  }
}
```

---

## Client-Side Stack Definition

When consuming a stack, you define a **client-side interface** that tells the SDK about your data types:

```typescript
import { defineStack, createListView, createStateView } from 'hyperstack-react';

interface Token {
  mint: string;
  name: string;
  symbol: string;
  totalVolume: number;
}

export const TokenStack = defineStack({
  name: 'my-tokens',
  
  views: {
    tokens: {
      list: createListView<Token>('Token/list'),
      state: createStateView<Token>('Token/state'),
    },
  },
  
  // Optional: utility functions
  helpers: {
    formatVolume: (vol: number) => `${(vol / 1e9).toFixed(2)} SOL`,
  },
});
```

This gives you:
- **Type safety** — TypeScript knows what fields exist
- **Autocomplete** — Your IDE helps you access the right views
- **Helpers** — Shared formatting/transformation logic

---

## Connection Lifecycle

```
disconnected → connecting → connected → (reconnecting) → connected
                                     ↘ error
```

| State | Meaning |
|-------|---------|
| `disconnected` | Not connected |
| `connecting` | Establishing WebSocket connection |
| `connected` | Active and receiving updates |
| `reconnecting` | Connection lost, attempting to restore |
| `error` | Failed to connect (check URL, network) |

The SDK handles reconnection automatically. Your subscriptions resume when the connection is restored.

---

## Summary

| Concept | What It Is |
|---------|------------|
| **Stack** | A deployed data pipeline transforming Solana events into structured data |
| **Entity** | A data object tracked by the stack (e.g., Token, Game, User) |
| **View** | A way to access entities (list for all, state for one) |
| **Update** | A real-time push when data changes |
| **Client Definition** | TypeScript interface connecting your app to a stack |

---

## Next Steps

- [React Guide](/using-stacks/react) — Build a complete React app
- [TypeScript Guide](/using-stacks/typescript) — Use with Node.js, Vue, Svelte
- [Build Your Own Stack](/building-stacks/workflow) — Create custom data streams
