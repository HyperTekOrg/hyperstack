---
title: Quickstart
sidebar:
  order: 1
description: Run the ORE demo and see live Solana data streaming in minutes.
---

import { Tabs, TabItem } from "@astrojs/starlight/components";
import Workflow from "../../../components/Workflow.astro";

This quickstart gets you streaming live Solana data in a few minutes using the ORE demo — a real, deployed Hyperstack stack for the ORE mining program. It's the fastest way to see Hyperstack in action.

:::note[What this covers]
This guide walks through the ORE demo only. It's a good starting point to understand how Hyperstack feels, but it doesn't cover building your own stacks or integrating with your own on-chain programs. For those paths, see the [Next Steps](#next-steps) section below.
:::

:::tip[Prefer AI-assisted development?]
If you're using Cursor, Claude Code, or another AI coding tool, check out [Build with AI](/agent-skills/overview/) — paste one prompt and your AI sets everything up.
:::

---

## Prerequisites

Choose how you want to run the CLI:

<Tabs>
<TabItem label="Cargo (Rust)">

Install the native binary via Cargo:

```bash
cargo install hyperstack-cli
```

Then use the `hs` command:

```bash
hs create my-app
```

This is the same CLI — Cargo installs it as `hs` while npm uses `hyperstack-cli`.

</TabItem>
<TabItem label="npx (no install)">

No installation needed — just run:

```bash
npx hyperstack-cli create my-app
```

This downloads and runs the CLI without installing it globally.

</TabItem>
<TabItem label="npm (global)">

Install globally via npm:

```bash
npm install -g hyperstack-cli
```

Then use the `hyperstack-cli` command:

```bash
hyperstack-cli create my-app
```

</TabItem>
</Tabs>

---

## Create Your App

<Tabs>
<TabItem label="Cargo (Rust)">

```bash
hs create my-app
```

</TabItem>
<TabItem label="npx (no install)">

```bash
npx hyperstack-cli create my-app
```

</TabItem>
<TabItem label="npm (global)">

```bash
hyperstack-cli create my-app
```

</TabItem>
</Tabs>

You'll be prompted to select a template:

| Template         | Description            | Run Command                                                  |
| ---------------- | ---------------------- | ------------------------------------------------------------ |
| `react-ore`      | React + Vite dashboard | `npm run dev` → open [localhost:5173](http://localhost:5173) |
| `typescript-ore` | TypeScript CLI client  | `npm start`                                                  |
| `rust-ore`       | Rust + Tokio client    | `cargo run`                                                  |

:::note[About the ORE demo]
All templates use the same example: **ORE mining rounds** — a real, live Solana program. The templates differ only in language/framework. Each connects to the same public ORE stack and streams identical data.
:::

Or specify the template directly:

<Tabs>
<TabItem label="Cargo (Rust)">

```bash
hs create my-app --template rust-ore  # or react-ore, typescript-ore
```

</TabItem>
<TabItem label="npx (no install)">

```bash
npx hyperstack-cli create my-app --template react-ore  # or typescript-ore, rust-ore
```

</TabItem>
<TabItem label="npm (global)">

```bash
hyperstack-cli create my-app --template react-ore  # or typescript-ore, rust-ore
```

</TabItem>
</Tabs>

That's it. You're streaming live Solana data.

---

## What You Just Built

The scaffolded app connects to a deployed **Hyperstack Stack** — a streaming data pipeline that:

1. **Watches Solana** for ORE mining program activity
2. **Transforms raw transactions** into structured round data (round ID, motherlode, deployment totals)
3. **Streams updates** to your app via WebSocket as they happen on-chain

<Workflow steps={[
  {
    title: "Solana",
    description: "ORE program"
  },
  {
    title: "Hyperstack",
    description: "ORE stack"
  },
  {
    title: "Your App",
    description: "Live feed"
  }
]} />

No RPC calls. No polling. No custom indexer. Just streaming data.

---

## Available Templates

| Template           | Command                            | What You Get                                          |
| ------------------ | ---------------------------------- | ----------------------------------------------------- |
| **react-ore**      | `npx hyperstack-cli create my-app` | React + Vite dashboard showing live ORE mining rounds |
| **typescript-ore** | `npx hyperstack-cli create my-app` | TypeScript CLI that streams ORE data to your terminal |
| **rust-ore**       | `npx hyperstack-cli create my-app` | Rust + Tokio client streaming ORE round updates       |

All templates connect to the public ORE stack at `wss://ore.stack.usehyperstack.com`.

You can also specify the template directly:

```bash
npx hyperstack-cli create my-app --template react-ore
```

---

## What's Inside

<Tabs>
<TabItem label="React Template">

The React template uses `hyperstack-react` with a pre-built stack definition:

```tsx
// App.tsx
import { HyperstackProvider } from "hyperstack-react";
import { OreDashboard } from "./components/OreDashboard";

export default function App() {
  return (
    <HyperstackProvider
      websocketUrl="wss://ore.stack.usehyperstack.com"
      autoConnect={true}
    >
      <OreDashboard />
    </HyperstackProvider>
  );
}
```

```tsx
// components/OreDashboard.tsx
import { useHyperstack } from "hyperstack-react";
import { ORE_STREAM_STACK } from "hyperstack-stacks/ore";

export function OreDashboard() {
  const { views, isConnected } = useHyperstack(ORE_STREAM_STACK);
  const { data: rounds } = views.OreRound.latest.use({ take: 5 });

  return (
    <div>
      <p>{isConnected ? "Live" : "Connecting..."}</p>
      {rounds?.map((round) => (
        <div key={round.id?.round_id}>
          Round #{round.id?.round_id} — Motherlode: {round.state?.motherlode}
        </div>
      ))}
    </div>
  );
}
```

</TabItem>
<TabItem label="TypeScript Template">

The TypeScript template uses `hyperstack-typescript` with typed views:

```typescript
// main.ts
import { HyperStack } from "hyperstack-typescript";
import { ORE_STREAM_STACK, type OreRound } from "hyperstack-stacks/ore";

const hs = await HyperStack.connect("wss://ore.stack.usehyperstack.com", {
  stack: ORE_STREAM_STACK,
});

for await (const update of hs.views.OreRound.latest.watch({ take: 1 })) {
  if (update.type === "upsert" || update.type === "patch") {
    console.log(`Round #${update.data.id?.round_id}`);
    console.log(`Motherlode: ${update.data.state?.motherlode}`);
  }
}
```

</TabItem>
<TabItem label="Rust Template">

The Rust template uses `hyperstack-sdk` with typed views:

```rust
// main.rs
use hyperstack_sdk::prelude::*;
use hyperstack_stacks::ore::{OreStack, OreRound};

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let hs = HyperStack::<OreStack>::connect().await?;

    let mut stream = hs.views.ore_round.latest().listen();

    while let Some(round) = stream.next().await {
        println!("Round # {:?}", round.id.round_id);
        println!("Motherlode: {:?}", round.state.motherlode);
    }
    Ok(())
}
```

</TabItem>
</Tabs>

---

## Using an AI Coding Agent?

Install Hyperstack agent skills so your AI can write correct code without you looking up docs:

```bash
npx skills add usehyperstack/skills
```

Now try asking your agent: "Show me the ORE mining round data in a table with live updates."

See [Build with AI](/agent-skills/overview/) for the full guide and prompt cookbook.

---

## Next Steps

Now that you've seen Hyperstack in action, where you go next depends on what you're building:

**Using an existing on-chain program that has a Hyperstack stack?**

- [Connect to a Stack](/using-stacks/connect/) — Add Hyperstack to an existing project
- [React SDK](/sdks/react/) — Build a full React app against a deployed stack
- [TypeScript SDK](/sdks/typescript/) — Use Hyperstack in Node.js, Vue, Svelte, or vanilla JS
- [Rust SDK](/sdks/rust/) — Native Rust client

**Have your own on-chain program and want to stream its data?**

- [Build Your Own Stack](/building-stacks/workflow/) — Create a custom data stream for any Solana program

**Want to understand what's happening under the hood?**

- [How It Works](/using-stacks/how-it-works/) — Stacks, Views, and how live data flows

**Using an AI coding tool?**

- [Build with AI](/agent-skills/overview/) — Let your agent write Hyperstack code with the right context
