---
title: Core Concepts
sidebar:
  order: 2
description: Understand Stacks, Views, and live data streaming.
---

import { Card, CardGrid } from "@astrojs/starlight/components";

Before diving deeper, here's a quick mental model of how Hyperstack works from the perspective of consuming data.

---

## The Three-Layer Model

```
┌──────────────────────────────────────────────────────────────┐
│  YOUR APP                                                    │
│  React hooks, TypeScript streams, or raw WebSocket           │
└──────────────────────────────────────────────────────────────┘
                              ▲
                              │ WebSocket (live updates)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  HYPERSTACK STACK                                            │
│  A deployed data pipeline that transforms on-chain events    │
│  into structured, typed data                                 │
└──────────────────────────────────────────────────────────────┘
                              ▲
                              │ Yellowstone gRPC (raw transactions)
                              ▼
┌──────────────────────────────────────────────────────────────┐
│  SOLANA                                                      │
│  On-chain programs emitting transactions and state changes   │
└──────────────────────────────────────────────────────────────┘
```

---

## What is a Stack?

A **Stack** is a deployed data pipeline that:

1. **Subscribes** to specific Solana program events
2. **Transforms** raw transaction data into structured entities
3. **Aggregates** values over time (sums, counts, etc.)
4. **Streams** updates to connected clients as they happen

Think of it as a "live query" against Solana — you define what data you want, and Hyperstack keeps it updated.

### Example: A Token Stack

A stack tracking pump.fun tokens might define:

```rust
#[entity(name = "PumpfunToken")]
pub struct PumpfunToken {
    #[from_instruction(Create::mint, primary_key)]
    pub mint: String,

    #[map(TokenAccount::name)]
    pub name: String,

    #[aggregate(from = Trade, field = amount, strategy = Sum)]
    pub total_volume: u64,
}
```

This tells Hyperstack:

- Create a `PumpfunToken` entity for each `Create` instruction
- Map the `name` field from the account state
- Sum all `Trade` amounts into `total_volume`

The result? A live, always-updating collection of tokens with their current stats.

---

## Views

**Views** are how you access data from a stack. There are two types:

### List View

Returns all entities as an array. Updates when any entity changes.

```typescript
// Get all tokens
const { data: tokens } = stack.views.tokens.list.use();
// tokens: PumpfunToken[]
```

### State View

Returns a single entity by its primary key. Updates when that specific entity changes.

```typescript
// Get one token by mint address
const { data: token } = stack.views.tokens.state.use({
  key: "So11111111111111111111111111111111111111112",
});
// token: PumpfunToken | undefined
```

### View Paths

Views are addressed using the format `{EntityName}/{mode}`:

| View Path     | Returns   | Use Case              |
| ------------- | --------- | --------------------- |
| `Token/list`  | `Token[]` | Show all tokens       |
| `Token/state` | `Token`   | Show one token by key |

---

## Live Updates

Unlike traditional APIs where you poll for changes, Hyperstack **pushes** updates to you.

### How It Works

1. Something happens on Solana (new token, trade, state change)
2. Hyperstack's VM processes the transaction
3. If it affects your subscribed views, you get an update
4. Your app re-renders automatically (React) or receives the event (TypeScript)

### Update Types

| Type     | Meaning                       |
| -------- | ----------------------------- |
| `upsert` | Entity was created or updated |
| `delete` | Entity was removed            |

```typescript
for await (const update of hs.subscribe("Token/list")) {
  if (update.type === "upsert") {
    console.log("Token changed:", update.data);
  } else if (update.type === "delete") {
    console.log("Token removed:", update.key);
  }
}
```

---

## Stack SDKs

A **stack** includes a typed SDK that tells the core Hyperstack client how to interact with that specific feed. The SDK contains:

- **Entity types** — The shape of your data
- **View definitions** — How to access entities (list, state, etc.)
- **Helpers** — Shared formatting and transformation logic

### Getting a Stack SDK

**From pre-built packages:**

```bash
npm install hyperstack-stacks
```

```typescript
import { PUMPFUN_STACK } from "hyperstack-stacks/pumpfun";
```

**From your own stack (via CLI):**

```bash
hs sdk create typescript my-stack
```

```typescript
import { MyStack } from "./generated/my-stack";
```

Both work identically — the SDK is the interface between your app and the data feed. You can share generated SDKs with your team or publish them to npm/crates.io so others can connect to your stack.

---

## Connection Lifecycle

```
disconnected → connecting → connected → (reconnecting) → connected
                                     ↘ error
```

| State          | Meaning                                |
| -------------- | -------------------------------------- |
| `disconnected` | Not connected                          |
| `connecting`   | Establishing WebSocket connection      |
| `connected`    | Active and receiving updates           |
| `reconnecting` | Connection lost, attempting to restore |
| `error`        | Failed to connect (check URL, network) |

The SDK handles reconnection automatically. Your subscriptions resume when the connection is restored.

---

## Summary

| Concept          | What It Is                                                               |
| ---------------- | ------------------------------------------------------------------------ |
| **Stack**        | A deployed data pipeline + typed SDK for consuming that feed             |
| **Entity**       | A data object tracked by the stack (e.g., Token, Game, User)             |
| **View**         | A way to access entities (list for all, state for one)                   |
| **Update**       | A live push when data changes                                            |
| **Stack SDK**    | Generated or pre-built package that tells the client how to use a stack  |

---

## Next Steps

<CardGrid>
  <Card title="Quickstart" icon="rocket">
    Scaffold a working app in under 2 minutes.
    [Get started →](/using-stacks/quickstart)
  </Card>
  <Card title="How It Works" icon="information">
    Deep dive into Hyperstack's architecture and data flow.
    [Learn more →](/concepts/overview)
  </Card>
  <Card title="Stack API" icon="open-book">
    Complete client-side API reference.
    [Read →](/concepts/stack-api)
  </Card>
  <Card title="Build Your Own Stack" icon="seti:rust">
    Create custom data streams for any Solana program.
    [Start building →](/building-stacks/workflow)
  </Card>
</CardGrid>
